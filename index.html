<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parab√©ns, Amor!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Nunito:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #ffe4e1 0%, #ffc1c1 100%);
            font-family: 'Nunito', sans-serif;
        }

        #ui-container {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            pointer-events: none;
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-family: 'Dancing Script', cursive;
            color: #c2185b;
            font-size: 4.5rem;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.6);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        h2 {
            color: #555;
            background: rgba(255, 255, 255, 0.9);
            display: inline-block;
            padding: 12px 35px;
            border-radius: 50px;
            margin-top: 15px;
            font-size: 1.4rem;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(194, 24, 91, 0.15);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #c2185b;
            font-weight: bold;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0.7;
        }

        /* Esconde o bot√£o antigo */
        #fireworks-btn { display: none; }

        .heart {
            position: absolute;
            font-size: 2rem;
            color: #ff1493;
            animation: hearts 8s linear infinite;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes hearts {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes confettiFall {
            to { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>Parab√©ns, Amor!</h1>
        <h2>Que orgulho gigante da sua conquista! ‚ù§Ô∏è</h2>
    </div>

    <div id="instructions">‚ú® Arraste para girar ‚Ä¢ Role para dar zoom ‚Ä¢ Curta a festa! ‚ú®</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // üëá CORRIGIDO COM OS NOMES DO SEU PRINT üëá
        // ============================================
        const minhasFotosURLs = [
            'corac.jpeg', 
            'flor.jpeg',
            'foto4.jpeg',
            'lilly.jpeg'
        ];
        // Nota: Se alguma foto n√£o aparecer, tente mudar .jpg para .jpeg no nome acima
        // ============================================

        // --- EFEITOS HTML ---
        function createHeart() {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = '‚ù§Ô∏è';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = (Math.random() * 3 + 5) + 's';
            heart.style.animationDelay = Math.random() * 2 + 's';
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 10000);
        }

        function createConfetti() {
            const colors = ['#ff6b9d', '#ffd93d', '#6bcf7f', '#4d9de0', '#e15554', '#f1c40f'];
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confettiFall ${Math.random() * 3 + 2}s linear`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 5000);
        }
        setInterval(createHeart, 800);
        setInterval(createConfetti, 200);

        // --- CENA ---
        const scene = new THREE.Scene();
        // Aumentei o range do fog para n√£o esconder os fogos
        scene.fog = new THREE.Fog(0xffc1c1, 60, 300);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 120;

        const ambientLight = new THREE.AmbientLight(0xffe4e1, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffedd5, 1);
        mainLight.position.set(30, 50, 30);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        const candleLight = new THREE.PointLight(0xff6600, 1.5, 15, 2);
        candleLight.position.set(0, 13.5, 0);
        scene.add(candleLight);

        // --- MATERIAIS ---
        const textureLoader = new THREE.TextureLoader();
        
        const matWood = new THREE.MeshStandardMaterial({ color: 0xb8956a, roughness: 0.8 });
        const matFloor = new THREE.MeshStandardMaterial({ color: 0xffd1dc, roughness: 0.9 });
        const matCakeChoco = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.4, metalness: 0.1 });
        const matCakeWhite = new THREE.MeshStandardMaterial({ color: 0xfff8f0, roughness: 0.2 });
        const matFrosting = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.15, emissive: 0xffeeff, emissiveIntensity: 0.2 });
        const matPlate = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.4 });
        const matCandleWax = new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.6, emissive: 0xffeecc, emissiveIntensity: 0.1 });

        // Ch√£o
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), matFloor);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);

        // Mesa
        const tableGroup = new THREE.Group();
        const tableTop = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 1.5, 128), matWood);
        tableTop.position.y = -0.75;
        tableTop.receiveShadow = true;
        tableTop.castShadow = true;
        const tableLeg = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 9, 64), matWood);
        tableLeg.position.y = -5.5;
        tableLeg.castShadow = true;
        tableLeg.receiveShadow = true;
        const tableBase = new THREE.Mesh(new THREE.CylinderGeometry(7, 7, 2, 128), matWood);
        tableBase.position.y = -10;
        tableBase.receiveShadow = true;
        tableBase.castShadow = true;
        tableGroup.add(tableTop, tableLeg, tableBase);
        scene.add(tableGroup);

        // Cadeiras
        function createChair(x, z) {
            const chairGroup = new THREE.Group();
            const seat = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 6), matWood);
            seat.position.y = -3.5;
            seat.castShadow = true;
            seat.receiveShadow = true;
            chairGroup.add(seat);
            const legGeo = new THREE.BoxGeometry(1, 7, 1);
            [{x: 2.5, z: 2.5}, {x: -2.5, z: 2.5}, {x: 2.5, z: -2.5}, {x: -2.5, z: -2.5}].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, matWood);
                leg.position.set(pos.x, -7, pos.z);
                leg.castShadow = true;
                chairGroup.add(leg);
            });
            const back = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 1), matWood);
            back.position.set(0, 0.5, -2.5);
            back.castShadow = true;
            chairGroup.add(back);
            chairGroup.position.set(x, 0, z);
            chairGroup.lookAt(0, 0, 0);
            scene.add(chairGroup);
        }
        createChair(0, 20); createChair(0, -20); createChair(20, 0); createChair(-20, 0);

        // Bolo
        const cakeGroup = new THREE.Group();
        const plateMesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 9.5, 0.8, 128), matPlate);
        plateMesh.receiveShadow = true;
        const plateRim = new THREE.Mesh(new THREE.TorusGeometry(9.7, 0.3, 32, 100), matPlate);
        plateRim.rotation.x = Math.PI/2;
        plateRim.position.y = 0.4;
        cakeGroup.add(plateMesh, plateRim);

        const layer1 = new THREE.Mesh(new THREE.CylinderGeometry(7.5, 7.5, 5, 128), matCakeChoco);
        layer1.position.y = 3;
        layer1.castShadow = true;
        cakeGroup.add(layer1);

        for(let i = 0; i < 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const swirl = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), matFrosting);
            swirl.position.set(Math.cos(angle) * 7.5, 5.5, Math.sin(angle) * 7.5);
            swirl.castShadow = true;
            cakeGroup.add(swirl);
        }

        const frostingRim = new THREE.Mesh(new THREE.TorusGeometry(6, 0.7, 32, 100), matFrosting);
        frostingRim.rotation.x = Math.PI/2;
        frostingRim.position.y = 5.5;
        cakeGroup.add(frostingRim);

        const layer2 = new THREE.Mesh(new THREE.CylinderGeometry(5.5, 5.5, 4, 128), matCakeWhite);
        layer2.position.y = 7.5;
        layer2.castShadow = true;
        cakeGroup.add(layer2);

        for(let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const wave = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), matFrosting);
            wave.position.set(Math.cos(angle) * 5.5, 9.5, Math.sin(angle) * 5.5);
            wave.castShadow = true;
            cakeGroup.add(wave);
        }

        const candleBody = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 3.5, 32), matCandleWax);
        candleBody.position.y = 11;
        candleBody.castShadow = true;
        cakeGroup.add(candleBody);
        const wick = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        wick.position.y = 12.85;
        cakeGroup.add(wick);
        const flameOuter = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 }));
        flameOuter.scale.set(1, 1.4, 1);
        flameOuter.position.y = 13.4;
        cakeGroup.add(flameOuter);
        const flameInner = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9 }));
        flameInner.scale.set(1, 1.5, 1);
        flameInner.position.y = 13.5;
        cakeGroup.add(flameInner);

        function createSprinkles() {
            const sprinkleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 4);
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            for(let i=0; i<50; i++) {
                const mat = new THREE.MeshStandardMaterial({ color: colors[i%4] });
                const mesh = new THREE.Mesh(sprinkleGeo, mat);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 5;
                mesh.position.set(Math.cos(angle)*r, 9.6, Math.sin(angle)*r);
                mesh.rotation.x = Math.PI/2;
                mesh.rotation.z = Math.random() * Math.PI;
                cakeGroup.add(mesh);
            }
        }
        createSprinkles();

        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + 0.2;
            const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0xc41e3a, roughness: 0.2, metalness: 0.3 }));
            cherry.position.set(Math.cos(angle) * 7, 5.8, Math.sin(angle) * 7);
            cherry.castShadow = true;
            cakeGroup.add(cherry);
        }
        cakeGroup.position.y = 0.4;
        scene.add(cakeGroup);

        // --- CARREGAMENTO DAS FOTOS CORRIGIDO ---
        const matPhotoPaper = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.1 });
        const photoRadius = 12;
        
        // Loader Manager para monitorar carregamento
        const manager = new THREE.LoadingManager();
        manager.onError = function (url) {
            console.error('Erro ao carregar ' + url + '. Verifique o nome do arquivo!');
        };
        const loader = new THREE.TextureLoader(manager);

        minhasFotosURLs.forEach((url, index) => {
            loader.load(url, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const photoGroup = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.12, 4.4), matPhotoPaper);
                frame.castShadow = true;
                frame.receiveShadow = true;
                photoGroup.add(frame);
                
                const pic = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 3.2), new THREE.MeshBasicMaterial({ map: texture }));
                pic.rotation.x = -Math.PI / 2;
                pic.position.set(0, 0.07, -0.3);
                photoGroup.add(pic);

                const angle = (index / minhasFotosURLs.length) * Math.PI * 2;
                photoGroup.position.set(Math.cos(angle) * photoRadius, 0.1, Math.sin(angle) * photoRadius);
                photoGroup.rotation.y = angle + Math.PI;
                scene.add(photoGroup);
            });
        });

        // Estrelas
        const starParticles = [];
        const starGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        for(let i = 0; i < 50; i++) {
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set((Math.random() - 0.5) * 60, Math.random() * 40 + 10, (Math.random() - 0.5) * 60);
            star.userData.speed = Math.random() * 0.02 + 0.01;
            starParticles.push(star);
            scene.add(star);
        }

        // Presentes
        function createGift(x, z, color, size) {
            const group = new THREE.Group();
            const boxGeo = new THREE.BoxGeometry(size, size, size);
            const boxMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = size / 2;
            box.castShadow = true;
            group.add(box);
            const ribV = new THREE.Mesh(new THREE.BoxGeometry(size * 1.05, size * 1.05, size * 0.15), new THREE.MeshStandardMaterial({ color: 0xff3366 }));
            ribV.position.y = size/2;
            group.add(ribV);
            const ribH = new THREE.Mesh(new THREE.BoxGeometry(size * 0.15, size * 1.05, size * 1.05), new THREE.MeshStandardMaterial({ color: 0xff3366 }));
            ribH.position.y = size/2;
            group.add(ribH);
            group.position.set(x, -10, z);
            group.rotation.y = Math.random();
            scene.add(group);
        }
        createGift(15, 15, 0xff8fa3, 4); createGift(18, 14, 0x80deea, 3); createGift(-15, 15, 0xfff59d, 3.5);
        createGift(-16, -16, 0xb39ddb, 4); createGift(15, -15, 0xff8fa3, 2.5); createGift(-14, 18, 0x80deea, 2);

        // Bal√µes
        const balloonMatBase = new THREE.MeshPhysicalMaterial({ roughness: 0.2, transmission: 0.95, thickness: 1.5, clearcoat: 1, side: THREE.DoubleSide });
        function createBalloon(x, z, color, h) {
            const group = new THREE.Group();
            const mat = balloonMatBase.clone();
            mat.color.setHex(color);
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(2.5, 64, 64), mat);
            mesh.castShadow = true;
            const line = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3([new THREE.Vector3(0,-2.5,0), new THREE.Vector3(1,-10,0), new THREE.Vector3(0,-22,0)]), 20, 0.08, 8, false), new THREE.MeshStandardMaterial({color: 0xffffff}));
            group.add(mesh, line);
            group.position.set(x, h, z);
            group.userData = { speed: 0.001 + Math.random()*0.003, offset: Math.random()*10, baseY: h };
            scene.add(group);
        }
        createBalloon(-22, -22, 0xff4081, 20); createBalloon(22, -18, 0x00bcd4, 18); createBalloon(-18, 25, 0xffeb3b, 22);
        createBalloon(20, 20, 0xff5722, 19); createBalloon(-15, -15, 0x9c27b0, 21); createBalloon(15, -20, 0x4caf50, 23);

        // --- FOGOS CORRIGIDOS E AUMENTADOS ---
        const fireworksParticles = [];
        class Firework {
            constructor() {
                this.particles = [];
                // Cores vivas
                this.color = new THREE.Color().setHSL(Math.random(), 1, 0.6);
                
                // Explodem mais perto (mais f√°cil de ver)
                this.x = (Math.random() - 0.5) * 50;
                this.z = (Math.random() - 0.5) * 50;
                // Altura reduzida para 35-55 (antes era 70+) para aparecer na tela
                this.targetY = 35 + Math.random() * 20; 
                
                const particleCount = 300;
                for(let i = 0; i < particleCount; i++) {
                    // Part√≠culas maiores
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.7, 8, 8), 
                        new THREE.MeshBasicMaterial({ color: this.color })
                    );
                    const speed = Math.random() * 1.5 + 0.5;
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = Math.random() * Math.PI;
                    
                    particle.position.set(this.x, this.targetY, this.z);
                    particle.userData = { 
                        velocity: new THREE.Vector3(
                            Math.sin(angle1) * Math.cos(angle2) * speed, 
                            Math.sin(angle2) * speed, 
                            Math.cos(angle1) * Math.cos(angle2) * speed
                        ), 
                        life: 1.0, 
                        gravity: 0.01 
                    };
                    scene.add(particle);
                    this.particles.push(particle);
                }
            }
            update() {
                let allDead = true;
                this.particles.forEach(particle => {
                    if(particle.userData.life > 0) {
                        allDead = false;
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= particle.userData.gravity;
                        particle.userData.life -= 0.015;
                        particle.scale.setScalar(particle.userData.life);
                    } else {
                        // Move para longe se morreu para n√£o atrapalhar
                        particle.position.y = -1000;
                    }
                });
                return allDead;
            }
            destroy() {
                this.particles.forEach(particle => {
                    particle.geometry.dispose();
                    particle.material.dispose();
                    scene.remove(particle);
                });
            }
        }
        
        let activeFireworks = [];
        function launchFirework() { 
            const firework = new Firework(); 
            activeFireworks.push(firework); 
            fireworksParticles.push(firework); 
        }
        // Frequ√™ncia alta de fogos
        setInterval(() => { if(Math.random() > 0.3) { launchFirework(); } }, 1200);

        // Anima√ß√£o
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();
            const flicker = 1 + Math.sin(time * 20) * 0.08 + Math.cos(time * 35) * 0.06;
            flameOuter.scale.set(flicker, flicker * 1.4, flicker);
            flameInner.scale.set(flicker * 0.8, flicker * 1.5, flicker * 0.8);
            candleLight.intensity = 1.5 + Math.sin(time * 30) * 0.4;
            candleLight.position.x = Math.sin(time * 15) * 0.15;
            candleLight.position.z = Math.cos(time * 12) * 0.15;
            cakeGroup.rotation.y = time * 0.1;
            scene.children.forEach(child => {
                if(child.userData.speed) {
                    child.position.y = child.userData.baseY + Math.sin(time * child.userData.speed + child.userData.offset) * 2;
                    child.rotation.z = Math.sin(time * child.userData.speed * 0.5) * 0.1;
                }
            });
            starParticles.forEach(star => {
                star.position.y += star.userData.speed;
                star.rotation.y += 0.02;
                if(star.position.y > 60) { star.position.y = 10; }
            });
            activeFireworks = activeFireworks.filter(firework => {
                const isDead = firework.update();
                if(isDead) { firework.destroy(); return false; }
                return true;
            });
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>
