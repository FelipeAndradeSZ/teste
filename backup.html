<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parab√©ns, Meu Amor!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Nunito:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #ffe4e1 0%, #ffc1c1 100%);
            font-family: 'Nunito', sans-serif;
        }

        #ui-container {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            pointer-events: none;
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-family: 'Dancing Script', cursive;
            color: #c2185b;
            font-size: 4.5rem;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.6);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        h2 {
            color: #555;
            background: rgba(255, 255, 255, 0.9);
            display: inline-block;
            padding: 12px 35px;
            border-radius: 50px;
            margin-top: 15px;
            font-size: 1.4rem;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(194, 24, 91, 0.15);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #c2185b;
            font-weight: bold;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0.7;
        }

        .heart {
            position: absolute;
            font-size: 2rem;
            color: #ff1493;
            animation: hearts 8s linear infinite;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes hearts {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>Parab√©ns, Amor!</h1>
        <h2>Que orgulho gigante da sua conquista! ‚ù§Ô∏è</h2>
    </div>

    <div id="instructions">‚ú® Arraste para girar ‚Ä¢ Role para dar zoom ‚Ä¢ Curta a festa! ‚ú®</div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        //  üëáüëáüëá FOTOS üëáüëáüëá
        // ============================================
        const minhasFotosURLs = [
            'https://imgur.com/a/cMHZ6fS', 
            'https://i.imgur.com/sPdtlSJ.jpeg', 
            'https://picsum.photos/id/40/300/300',  
            'https://picsum.photos/id/65/300/300',
            'https://picsum.photos/id/1062/300/300'
        ];

        // --- EFEITOS HTML (Confetes/Cora√ß√µes) ---
        function createHeart() {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = '‚ù§Ô∏è';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = (Math.random() * 3 + 5) + 's';
            heart.style.animationDelay = Math.random() * 2 + 's';
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 10000);
        }

        function createConfetti() {
            const colors = ['#ff6b9d', '#ffd93d', '#6bcf7f', '#4d9de0', '#e15554', '#f1c40f'];
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confettiFall ${Math.random() * 3 + 2}s linear`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 5000);
        }

        setInterval(createHeart, 800);
        setInterval(createConfetti, 200);

        // --- CENA THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffc1c1, 50, 150);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        // MELHORIA DE SOMBRA: Usando PCFSoft para sombras mais suaves e limpas
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 100;

        // --- LUZES ---
        const ambientLight = new THREE.AmbientLight(0xffe4e1, 0.6);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffedd5, 1);
        mainLight.position.set(30, 50, 30);
        mainLight.castShadow = true;
        // MELHORIA DE SOMBRA: Aumentando a resolu√ß√£o do mapa de sombra
        mainLight.shadow.mapSize.width = 4096; 
        mainLight.shadow.mapSize.height = 4096;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 150;
        // Ajuste fino para evitar "shadow acne"
        mainLight.shadow.bias = -0.0005;
        // Raio para suavizar as bordas com PCFSoft
        mainLight.shadow.radius = 5; 
        scene.add(mainLight);

        const candleLight = new THREE.PointLight(0xff6600, 1.5, 15, 2);
        candleLight.position.set(0, 13.5, 0);
        // Luz da vela n√£o projeta sombra para economizar performance e evitar artefatos
        candleLight.castShadow = false; 
        scene.add(candleLight);

        // --- MATERIAIS ---
        const textureLoader = new THREE.TextureLoader();
        
        const matWood = new THREE.MeshStandardMaterial({ color: 0xb8956a, roughness: 0.8 });
        const matFloor = new THREE.MeshStandardMaterial({ color: 0xffd1dc, roughness: 0.9 });
        
        // Material de Chocolate
        const matCakeChoco = new THREE.MeshStandardMaterial({ 
            color: 0x3e2723, // Marrom escuro
            roughness: 0.4,
            metalness: 0.1
        });
        
        const matCakeWhite = new THREE.MeshStandardMaterial({ color: 0xfff8f0, roughness: 0.2 });
        const matFrosting = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.15, emissive: 0xffeeff, emissiveIntensity: 0.1 });
        const matPlate = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.4 });
        const matCandleWax = new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.6, emissive: 0xffeecc, emissiveIntensity: 0.1 });

        // --- CH√ÉO ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), matFloor);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- MESA ---
        const tableGroup = new THREE.Group();
        const tableTop = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 1.5, 128), matWood);
        tableTop.position.y = -0.75;
        tableTop.receiveShadow = true;
        tableTop.castShadow = true;
        
        const tableLeg = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 9, 64), matWood);
        tableLeg.position.y = -5.5;
        tableLeg.castShadow = true;
        tableLeg.receiveShadow = true;

        const tableBase = new THREE.Mesh(new THREE.CylinderGeometry(7, 7, 2, 128), matWood);
        tableBase.position.y = -10;
        tableBase.receiveShadow = true;
        tableBase.castShadow = true;
        
        tableGroup.add(tableTop, tableLeg, tableBase);
        scene.add(tableGroup);

        // --- CADEIRAS ---
        function createChair(x, z) {
            const chairGroup = new THREE.Group();
            const seat = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 6), matWood);
            seat.position.y = -3.5;
            seat.castShadow = true;
            seat.receiveShadow = true;
            chairGroup.add(seat);

            const legGeo = new THREE.BoxGeometry(1, 7, 1);
            [{x: 2.5, z: 2.5}, {x: -2.5, z: 2.5}, {x: 2.5, z: -2.5}, {x: -2.5, z: -2.5}].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, matWood);
                leg.position.set(pos.x, -7, pos.z);
                leg.castShadow = true;
                chairGroup.add(leg);
            });

            const back = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 1), matWood);
            back.position.set(0, 0.5, -2.5);
            back.castShadow = true;
            chairGroup.add(back);

            chairGroup.position.set(x, 0, z);
            chairGroup.lookAt(0, 0, 0);
            scene.add(chairGroup);
        }
        createChair(0, 20);
        createChair(0, -20);
        createChair(20, 0);
        createChair(-20, 0);

        // --- BOLO DE CHOCOLATE ---
        const cakeGroup = new THREE.Group();
        
        const plateMesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 9.5, 0.8, 128), matPlate);
        plateMesh.receiveShadow = true;
        const plateRim = new THREE.Mesh(new THREE.TorusGeometry(9.7, 0.3, 32, 100), matPlate);
        plateRim.rotation.x = Math.PI/2;
        plateRim.position.y = 0.4;
        cakeGroup.add(plateMesh, plateRim);

        // Camada 1 (Chocolate)
        const layer1 = new THREE.Mesh(new THREE.CylinderGeometry(7.5, 7.5, 5, 128), matCakeChoco);
        layer1.position.y = 3;
        layer1.castShadow = true;
        cakeGroup.add(layer1);

        // Suspiros/Chantilly
        for(let i = 0; i < 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const swirl = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), matFrosting);
            swirl.position.set(Math.cos(angle) * 7.5, 5.5, Math.sin(angle) * 7.5);
            swirl.castShadow = true;
            cakeGroup.add(swirl);
        }

        // Camada 2 (Branca)
        const layer2 = new THREE.Mesh(new THREE.CylinderGeometry(5.5, 5.5, 4, 128), matCakeWhite);
        layer2.position.y = 7.5;
        layer2.castShadow = true;
        cakeGroup.add(layer2);

        // Granulados
        function createSprinkles() {
            const sprinkleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 4);
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            for(let i=0; i<40; i++) {
                const mat = new THREE.MeshStandardMaterial({ color: colors[i%4] });
                const mesh = new THREE.Mesh(sprinkleGeo, mat);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 5;
                mesh.position.set(Math.cos(angle)*r, 9.51, Math.sin(angle)*r);
                mesh.rotation.x = Math.PI/2;
                mesh.rotation.z = Math.random() * Math.PI;
                cakeGroup.add(mesh);
            }
        }
        createSprinkles();

        // Vela
        const candleBody = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 3.5, 32), matCandleWax);
        candleBody.position.y = 11;
        candleBody.castShadow = true;
        cakeGroup.add(candleBody);

        const wick = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        wick.position.y = 12.85;
        cakeGroup.add(wick);

        const flameOuter = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 }));
        flameOuter.scale.set(1, 1.4, 1);
        flameOuter.position.y = 13.4;
        cakeGroup.add(flameOuter);

        const flameInner = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9 }));
        flameInner.scale.set(1, 1.5, 1);
        flameInner.position.y = 13.5;
        cakeGroup.add(flameInner);
        
        // Cerejas/Morangos
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + 0.2;
            const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0xc41e3a, roughness: 0.3 }));
            cherry.position.set(Math.cos(angle) * 7, 5.8, Math.sin(angle) * 7);
            cherry.castShadow = true;
            cakeGroup.add(cherry);
        }

        cakeGroup.position.y = 0.4;
        scene.add(cakeGroup);

        // --- FOTOS ---
        const matPhotoPaper = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const photoRadius = 12;
        minhasFotosURLs.forEach((url, index) => {
            textureLoader.load(url, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const photoGroup = new THREE.Group();
                
                const frame = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.12, 4.4), matPhotoPaper);
                frame.castShadow = true;
                photoGroup.add(frame);
                
                const pic = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 3.2), new THREE.MeshBasicMaterial({ map: texture }));
                pic.rotation.x = -Math.PI / 2;
                pic.position.set(0, 0.07, -0.3);
                photoGroup.add(pic);

                const angle = (index / minhasFotosURLs.length) * Math.PI * 2;
                photoGroup.position.set(Math.cos(angle) * photoRadius, 0.1, Math.sin(angle) * photoRadius);
                photoGroup.rotation.y = angle + Math.PI;
                scene.add(photoGroup);
            });
        });

        // --- PRESENTES ORGANIZADOS ---
        function createGift(x, z, color, size) {
            const group = new THREE.Group();
            const boxGeo = new THREE.BoxGeometry(size, size, size);
            const boxMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = size / 2;
            box.castShadow = true;
            group.add(box);

            // Fita Vertical
            const ribV = new THREE.Mesh(new THREE.BoxGeometry(size * 1.05, size * 1.05, size * 0.15), new THREE.MeshStandardMaterial({ color: 0xff3366 }));
            ribV.position.y = size/2;
            group.add(ribV);

            // Fita Horizontal
            const ribH = new THREE.Mesh(new THREE.BoxGeometry(size * 0.15, size * 1.05, size * 1.05), new THREE.MeshStandardMaterial({ color: 0xff3366 }));
            ribH.position.y = size/2;
            group.add(ribH);

            group.position.set(x, -10, z);
            group.rotation.y = Math.random();
            scene.add(group);
        }

        createGift(15, 15, 0xff8fa3, 4);
        createGift(18, 14, 0x80deea, 3);
        createGift(-15, 15, 0xfff59d, 3.5);
        createGift(-16, -16, 0xb39ddb, 4);
        createGift(15, -15, 0xff8fa3, 2.5);
        createGift(-14, 18, 0x80deea, 2);

        // --- BAL√ïES ---
        const balloonMatBase = new THREE.MeshPhysicalMaterial({ roughness: 0.2, transmission: 0.95, thickness: 1.5, clearcoat: 1, side: THREE.DoubleSide });
        function createBalloon(x, z, color, h) {
            const group = new THREE.Group();
            const mat = balloonMatBase.clone();
            mat.color.setHex(color);
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(2.5, 32, 32), mat);
            mesh.castShadow = true;
            const line = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3([new THREE.Vector3(0,-2.5,0), new THREE.Vector3(1,-10,0), new THREE.Vector3(0,-22,0)]), 20, 0.08, 8, false), new THREE.MeshStandardMaterial({color: 0xffffff}));
            group.add(mesh, line);
            group.position.set(x, h, z);
            group.userData = { speed: 0.001 + Math.random()*0.003, offset: Math.random()*10, baseY: h };
            scene.add(group);
        }
        createBalloon(-22, -22, 0xff4081, 20);
        createBalloon(22, -18, 0x00bcd4, 18);
        createBalloon(-18, 25, 0xffeb3b, 22);
        createBalloon(20, 20, 0xff5722, 19);
        createBalloon(-15, -15, 0x9c27b0, 21);
        createBalloon(15, -20, 0x4caf50, 23);

        // --- ESTRELAS ---
        const starParticles = [];
        const starGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        for(let i = 0; i < 50; i++) {
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set((Math.random()-0.5)*60, Math.random()*40+10, (Math.random()-0.5)*60);
            star.userData.speed = Math.random() * 0.02 + 0.01;
            starParticles.push(star);
            scene.add(star);
        }

        // --- SISTEMA DE FOGOS DE ARTIF√çCIO AUTOM√ÅTICO ---
        const fireworksParticles = [];
        let activeFireworks = [];

        class Firework {
            constructor() {
                this.particles = [];
                this.color = new THREE.Color(Math.random(), Math.random(), Math.random());
                this.x = (Math.random() - 0.5) * 50;
                this.z = (Math.random() - 0.5) * 50;
                this.targetY = 25 + Math.random() * 25;
                
                for(let i = 0; i < 80; i++) {
                    const particle = new THREE.Mesh(new THREE.SphereGeometry(0.3, 4, 4), new THREE.MeshBasicMaterial({ color: this.color }));
                    const speed = Math.random() * 0.6 + 0.2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.set(this.x, this.targetY, this.z);
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            Math.sin(phi) * Math.cos(theta) * speed,
                            Math.cos(phi) * speed,
                            Math.sin(phi) * Math.sin(theta) * speed
                        ),
                        life: 1.0 + Math.random()*0.5
                    };
                    scene.add(particle);
                    this.particles.push(particle);
                }
            }
            update() {
                let allDead = true;
                this.particles.forEach(p => {
                    if(p.userData.life > 0) {
                        allDead = false;
                        p.position.add(p.userData.velocity);
                        p.userData.velocity.y -= 0.015; // Gravidade
                        p.userData.life -= 0.02;
                        p.scale.setScalar(p.userData.life);
                    } else {
                        p.visible = false;
                    }
                });
                return allDead;
            }
            destroy() {
                this.particles.forEach(p => scene.remove(p));
            }
        }

        setInterval(() => {
            if(Math.random() > 0.3) { 
                const fw = new Firework();
                activeFireworks.push(fw);
            }
        }, 1500); 

        // --- ANIMA√á√ÉO ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            // Vela e luz
            const flicker = 1 + Math.sin(time * 20) * 0.08;
            flameOuter.scale.set(flicker, flicker * 1.4, flicker);
            candleLight.intensity = 1.5 + Math.sin(time * 30) * 0.4;

            // Rota√ß√£o suave do bolo
            cakeGroup.rotation.y = time * 0.1;

            // Bal√µes
            scene.children.forEach(child => {
                if(child.userData.speed) {
                    child.position.y = child.userData.baseY + Math.sin(time * 2 + child.userData.offset) * 1.5;
                }
            });

            // Estrelas subindo
            starParticles.forEach(star => {
                star.position.y += star.userData.speed;
                if(star.position.y > 60) star.position.y = 10;
            });

            // Fogos
            activeFireworks = activeFireworks.filter(fw => {
                const dead = fw.update();
                if(dead) fw.destroy();
                return !dead;
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>